#include <stdlib.h>#include <string.h>#include <png.h>#include "CFontEngine.h"#include "../FileSystem/FileHandling.h"OpenUtility::CFontLoader::CFontLoader(const char *font,unsigned int size,const char *cache) :	isInit(false),	FontTexture(NULL),	Size(size){	if (FT_Init_FreeType(&library)) return;	if (FT_New_Face(library,font,0,&face)) return;	memset(CharsData,0,sizeof(CharsData));	CStream file;	if (cache) file=cache;	else file='.';	file.AddFormatStream("/%s.%s.%u.font",face->family_name,face->style_name,size);	if (!isFile(file))	{		if (!GenFont(file,size)) return;	}	else	{		if (!ReadFont(file)) return;	}	isInit=true;}OpenUtility::CFontLoader::~CFontLoader(){	FT_Done_FreeType(library);	delete FontTexture;}OpenUtility::CFontLoader::CFontLoader(const CFontLoader &obj){}OpenUtility::CFontLoader& OpenUtility::CFontLoader::operator=(const CFontLoader &obj){	return(*this);}int OpenUtility::CFontLoader::GetFile16b(FILE *fp){	int c,val;	val=0;	c=fgetc(fp);	if (!feof(fp)) val|=c<<8;	c=fgetc(fp);	if (!feof(fp)) val|=c;	return(val);}void OpenUtility::CFontLoader::PutFile16b(FILE *fp,int val){	fputc((val>>8)&0xff,fp);	fputc(val&0xff,fp);}bool OpenUtility::CFontLoader::ReadFont(CStream &file){	unsigned char header[6];	unsigned int i,nbChar;	FILE *fp;	if ((fp=fopen(file,"r"))==NULL) return(false);	// read the header	if ((fread(header,1,6,fp)!=6) || (memcmp(header,"OUFONT",6)!=0)) return(false);	nbChar=GetFile16b(fp);	if (nbChar>256) return(false);	for (i=0;i<nbChar;i++)	{		CharsData[i].Advance=GetFile16b(fp);		if (feof(fp))		{			fclose(fp);			return(false);		}		if (CharsData[i].Advance==0) continue;		CharsData[i].texW=GetFile16b(fp);		CharsData[i].texH=GetFile16b(fp);		CharsData[i].BearingX=GetFile16b(fp);		CharsData[i].BearingY=GetFile16b(fp);		CharsData[i].texX=GetFile16b(fp);		CharsData[i].texY=GetFile16b(fp);	}	unsigned char *buffer;	unsigned int width,height;	if ((buffer=ReadPngBitmap(fp,width,height))==NULL)	{		return(false);	}	fclose(fp);	FontTexture=CTexture::LoadTextureMemory(buffer,width,height,CTexture::EPModeG);	free(buffer);	return(FontTexture!=NULL);}bool OpenUtility::CFontLoader::GenFont(CStream &file,unsigned int size){	const int sizeTW=512;	if (FT_Set_Pixel_Sizes(face,0,size)) return(false);	FT_GlyphSlot slot=face->glyph;	int w,h,x=0,y=0,tmp=0;	for (unsigned int n=0;n<256;n++)	{		FT_UInt glyph_index=FT_Get_Char_Index(face,n);		if ((glyph_index==0) || FT_Load_Glyph(face,glyph_index,FT_LOAD_DEFAULT)) continue;		w=slot->metrics.width>>6;		h=slot->metrics.height>>6;		if (w>sizeTW) return(false);		if (x+w>sizeTW)		{			x=0;			y+=tmp+1;			tmp=0;		}		if (tmp<h) tmp=h;		x+=w+1;	}	if (y>0) x=sizeTW;	y+=tmp+1;	unsigned char *buffer;	unsigned int width,height;	FILE *fp;	if ((fp=fopen(file,"w"))==NULL) return(false);	fprintf(fp,"OUFONT");	PutFile16b(fp,256);	width=x;	height=y;	if ((buffer=(unsigned char*)calloc(width*height,sizeof(unsigned char)))==NULL) return(false);	x=0;	y=0;	tmp=0;	for (unsigned int n=0;n<256;n++)	{		FT_UInt glyph_index=FT_Get_Char_Index(face,n);		if ((glyph_index==0) || FT_Load_Glyph(face,glyph_index,FT_LOAD_RENDER))		{			CharsData[n].Advance=0;			PutFile16b(fp,0);			continue;		}		w=slot->metrics.width>0 ? slot->metrics.width>>6 : 0;		h=slot->metrics.height>0 ? slot->metrics.height>>6 : 0;		if (slot->bitmap.width!=w || slot->bitmap.rows!=h)		{			printf("erreur font size !!!\n");			fclose(fp);			return(false);		}		if (x+w>sizeTW)		{			x=0;			y+=tmp+1;			tmp=0;		}		if (tmp<h) tmp=h;		PutFile16b(fp,CharsData[n].Advance=slot->metrics.horiAdvance>0 ? slot->metrics.horiAdvance>>6 : 0);		PutFile16b(fp,CharsData[n].texW=w);		PutFile16b(fp,CharsData[n].texH=h);		PutFile16b(fp,CharsData[n].BearingX=slot->metrics.horiBearingX>0 ? slot->metrics.horiBearingX>>6 : 0);		PutFile16b(fp,CharsData[n].BearingY=slot->metrics.horiBearingY ? slot->metrics.horiBearingY>>6 : 0);		PutFile16b(fp,CharsData[n].texX=x);		PutFile16b(fp,CharsData[n].texY=y);		for (int i=0;i<slot->bitmap.rows;i++)			memcpy(&buffer[x+(y+i)*width],&slot->bitmap.buffer[i*slot->bitmap.pitch],slot->bitmap.width);		x+=w+1;	}	bool res=WritePngBitmap(fp,buffer,width,height);	fclose(fp);	FontTexture=CTexture::LoadTextureMemory(buffer,width,height,CTexture::EPModeG);	free(buffer);	return(res);}bool OpenUtility::CFontLoader::WritePngBitmap(FILE *fp,unsigned char *bitmap,unsigned int width,unsigned int height){	png_structp png_ptr=NULL;	png_infop info_ptr=NULL;	size_t y;	png_byte **row_pointers=NULL;	int pixel_size=1;	int depth=8;	if ((png_ptr=png_create_write_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL))==NULL) return(false);	if (((info_ptr=png_create_info_struct(png_ptr))==NULL) || setjmp(png_jmpbuf(png_ptr)))	{		png_destroy_write_struct(&png_ptr,&info_ptr);		return(false);	}	// Set image attributes	png_set_IHDR(png_ptr,info_ptr,width,height,depth,PNG_COLOR_TYPE_GRAY,PNG_INTERLACE_NONE,PNG_COMPRESSION_TYPE_DEFAULT,PNG_FILTER_TYPE_DEFAULT);	// Initialize rows of PNG	row_pointers=(png_byte**)png_malloc(png_ptr,height*sizeof(png_byte*));	for (y=0;y<height;++y)	{		png_byte *row=(png_byte*)png_malloc(png_ptr,sizeof(png_byte)*width*pixel_size);		row_pointers[y]=row;		memcpy(row,bitmap,width*pixel_size);		bitmap+=width*pixel_size;	}	// Write the image data to file	png_init_io(png_ptr,fp);	png_set_rows(png_ptr,info_ptr,row_pointers);	png_write_png(png_ptr,info_ptr,PNG_TRANSFORM_IDENTITY,NULL);	for (y=0;y<height;y++) png_free(png_ptr,row_pointers[y]);	png_free(png_ptr,row_pointers);	png_destroy_write_struct(&png_ptr,&info_ptr);	return true;}unsigned char* OpenUtility::CFontLoader::ReadPngBitmap(FILE *fp,unsigned int &width,unsigned int &height){	png_byte header[8];	// read the header	fread(header,1,8,fp);	if (png_sig_cmp(header,0,8)) return NULL;	png_structp png_ptr=NULL;	png_infop info_ptr=NULL;	png_infop end_info=NULL;	if ((png_ptr=png_create_read_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL))==NULL) return NULL;	if ((info_ptr=png_create_info_struct(png_ptr))==NULL)	{		png_destroy_read_struct(&png_ptr,(png_infopp)NULL,(png_infopp)NULL);		return NULL;	}	// create png info struct	if ((end_info=png_create_info_struct(png_ptr))==0)	{		png_destroy_read_struct(&png_ptr,&info_ptr,(png_infopp)NULL);		return NULL;	}	// the code in this if statement gets called if libpng encounters an error	if (setjmp(png_jmpbuf(png_ptr)))	{		png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);		return NULL;	}	// Read the image data from file	int bit_depth,color_type;	unsigned long w,h;	png_init_io(png_ptr,fp);	png_set_sig_bytes(png_ptr,8);	png_read_info(png_ptr,info_ptr);	png_get_IHDR(png_ptr,info_ptr,&w,&h,&bit_depth,&color_type,NULL,NULL,NULL);	if ((color_type!=PNG_COLOR_TYPE_GRAY) || (bit_depth!=8))	{		png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);		return NULL;	}	width=w;	height=h;	png_read_update_info(png_ptr,info_ptr);	int rowbytes=png_get_rowbytes(png_ptr,info_ptr);	png_byte *image_data;	if ((image_data=(png_byte*)malloc(rowbytes*h*sizeof(png_byte)+15))==NULL)	{		png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);		return NULL;	}	png_bytep *row_pointers;	if ((row_pointers=(png_bytep*)malloc(h*sizeof(png_bytep)))==NULL)	{		png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);		free(image_data);		return NULL;	}	for (unsigned long i=0;i<h;i++)		row_pointers[i]=image_data+i*rowbytes;	png_read_image(png_ptr,row_pointers);	png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);	free(row_pointers);	return(image_data);}